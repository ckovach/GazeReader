function varargout = RegManager(varargin)
% REGMANAGER M-file for RegManager.fig
%      REGMANAGER, by itself, creates a new REGMANAGER or raises the existing
%      singleton*.
%
%      H = REGMANAGER returns the handle to a new REGMANAGER or the handle to
%      the existing singleton*.
%
%      REGMANAGER('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in REGMANAGER.M with the given input arguments.
%
%      REGMANAGER('Property','Value',...) creates a new REGMANAGER or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before RegManager_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to RegManager_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help RegManager

% Last Modified by GUIDE v2.5 14-Jan-2008 23:43:08

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @RegManager_OpeningFcn, ...
                   'gui_OutputFcn',  @RegManager_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before RegManager is made visible.
function RegManager_OpeningFcn(hObject, eventdata, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to RegManager (see VARARGIN)


parent = varargin{1};

setappdata(handles.figure1,'parent',parent);
setappdata(parent,'RegManager',handles.figure1);
setappdata(parent,'CurrentRegressorGroup',0);
setappdata(parent,'CurrentRegressor',0);

setappdata(parent,'CurrentModel',1);

rmfuns.update = @() UpdateFields([],[],handles);
rmfuns.designMatrix= @(varargin) designMatrix([],[],handles,varargin{:});

setappdata(parent,'RegManagerFunctions',rmfuns);

InitializeRegressors(hObject, eventdata, handles)

UpdateFields(hObject, eventdata, handles)

% Choose default command line output for RegManager
handles.output = hObject;
% Update handles structure
guidata(hObject, handles);

% UIWAIT makes RegManager wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = RegManager_OutputFcn(hObject, eventdata, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --- Executes on selection change in regressorGroupList.
function regressorGroupList_Callback(hObject, eventdata, handles)
% hObject    handle to regressorGroupList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns regressorGroupList contents as cell array
%        contents{get(hObject,'Value')} returns selected item from regressorGroupList


parent = getappdata(handles.figure1,'parent');

selected = get(handles.regressorGroupList,'value');

setappdata(parent,'CurrentRegressorGroup',selected(1) - 1)

UpdateFields(hObject, eventdata, handles)


% --- Executes during object creation, after setting all properties.
function regressorGroupList_CreateFcn(hObject, eventdata, handles)
% hObject    handle to regressorGroupList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end


% --- Executes on selection change in regList.
function regList_Callback(hObject, eventdata, handles)
% hObject    handle to regList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Hints: contents = get(hObject,'String') returns regList contents as cell array
%        contents{get(hObject,'Value')} returns selected item from regList

parent = getappdata(handles.figure1,'parent');

selected = get(handles.regList,'value');

setappdata(parent,'CurrentRegressor',selected - 1)

UpdateFields(hObject, eventdata, handles)


% --- Executes during object creation, after setting all properties.
function regList_CreateFcn(hObject, eventdata, handles)
% hObject    handle to regList (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    empty - handles not created until after all CreateFcns called

% Hint: listbox controls usually have a white background on Windows.
%       See ISPC and COMPUTER.
if ispc && isequal(get(hObject,'BackgroundColor'), get(0,'defaultUicontrolBackgroundColor'))
    set(hObject,'BackgroundColor','white');
end



% --------------------------------------------------------------------
function importFromWorkspaceMenu_Callback(hObject, eventdata, handles)
% hObject    handle to importFromWorkspaceMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function importFromTextMenu_Callback(hObject, eventdata, handles)
% hObject    handle to importFromTextMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function regGroupRemoveMenu_Callback(hObject, eventdata, handles)
% hObject    handle to regGroupRemoveMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function splitMenu_Callback(hObject, eventdata, handles)
% hObject    handle to splitMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function poolMenu_Callback(hObject, eventdata, handles)
% hObject    handle to poolMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function interactionMenu_Callback(hObject, eventdata, handles)
% hObject    handle to interactionMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function regRemoveMenu_Callback(hObject, eventdata, handles)
% hObject    handle to regRemoveMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_1_Callback(hObject, eventdata, handles)
% hObject    handle to Untitled_1 (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function regGroupMenu_Callback(hObject, eventdata, handles)
% hObject    handle to regGroupMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function regMenu_Callback(hObject, eventdata, handles)
% hObject    handle to regMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function UpdateFields(hObject, eventdata, handles)

parent = getappdata(handles.figure1,'parent');

currentRegressorGroup = getappdata(parent,'CurrentRegressorGroup');
% currentRegressor = getappdata(parent,'CurrentRegressor');
currentDataSet = getappdata(parent,'CurrentDataSet');
regData = getappdata(parent,'regData');

if currentDataSet == 0
    fprintf('\nNo data set selected...')
    return
end
lbls = {regData(currentDataSet).regressors.label};
if currentRegressorGroup > 0 &&  currentRegressorGroup <= length(regData(currentDataSet).regressors)
    nreg = regData(currentDataSet).regressors(currentRegressorGroup).Npar;
else
    nreg = 0;
end

liststrGr = cat(2,{'none selected'},lbls);
liststrR = cat(2,{'none selected'},cellfun(@num2str,mat2cell(1:nreg,1,ones(1,nreg)),'UniformOutput',0));

if get(handles.regressorGroupList,'value')> length(liststrGr)
    set(handles.regressorGroupList,'value',1)
    setappdata(parent,'CurrentRegressorGroup',0);    
end
if get(handles.regList,'value')> length(liststrR)
    set(handles.regList,'value',1)
    setappdata(parent,'CurrentRegressor',0)
end
set(handles.regressorGroupList,'string',liststrGr);
set(handles.regList,'string',liststrR);

if get(handles.displayCheck,'value')    
    DrawRegressor(hObject, eventdata, handles)
end


% --------------------------------------------------------------------
function DrawRegressor(hObject, eventdata, handles)

%Displays the value of regressors for each bin in the main axis

parent = getappdata(handles.figure1,'parent');

regData = getappdata(parent,'regData');
currentRegressorGroup =  getappdata(parent,'CurrentRegressorGroup');
currentRegressor =  getappdata(parent,'CurrentRegressor');
currentFixation =  getappdata(parent,'CurrentFixation');
currentTrial =  getappdata(parent,'CurrentTrial');
currentDataSet =  getappdata(parent,'CurrentDataSet');

trialData =  getappdata(parent,'trialData');
binData =  getappdata(parent,'binData');

if isempty(currentRegressor) || currentRegressor ==0  || currentRegressor > length(regData(currentDataSet).regressors) 
    return
end
if currentTrial > 0 && ~isempty(currentFixation) &&...
                currentFixation == 0 && ~isempty(trialData(currentDataSet).trials(currentTrial).fixations) 
    currentFixation = trialData(currentDataSet).trials(currentTrial).fixations(1);
elseif isempty(currentFixation)  || currentFixation == 0  || currentFixation > max(regData(currentDataSet).fixationIndex) 
    return
end
getpts = currentFixation == regData(currentDataSet).fixationIndex;
R = regData(currentDataSet).regressors(currentRegressorGroup).value(getpts,:);
if isequal(regData(currentDataSet).regressors(currentRegressorGroup).info.form,'sparse')
    R = unsparsify(R,'transpose');
end
tr = unique(regData(currentDataSet).trialIndex(getpts));

if length(tr) > 1
    error('A fixation appears to be associated with multiple trials.')
end

Zdata = R(:,currentRegressor);

if isempty(tr)
    return
end
trbincode = trialData(currentDataSet).trials(tr).binGroup;
bincodes = [binData.groups.code];

bindex = find(ismember(bincodes,trbincode));

Zdata = mat2cell(Zdata,cat(1,binData.groups(bindex).nbin),1);

bmfuns = getappdata(parent,'binManagerFunctions');


% crind = 0;
% bmh = getappdata(parent,'BinManager');
% bmhandles = guidata(bmh);
% set(bmhandles.binList,'value',bindex+1);

% for i = 1:length(bindex)
%     
% bgr = binData.groups(bindex(i));

 setappdata(parent,'CurrentBinGroup',0);

bmfuns.clear( parent );
ph = bmfuns.draw(parent, Zdata, bindex);

setappdata(parent,'patchHandles',ph)

% crind = crind + bgr.nbin;
% end



% % --------------------------------------------------------------------
% function  DM = designMatrix(hObject, eventdata, handles)

% --------------------------------------------------------------------
function InitializeRegressors(hObject, eventdata, handles)

%Set up the default regressors, fixation bin position, and polar
%coordinates wrt to the current and previous fixation location

parent = getappdata(handles.figure1,'parent');

crdat = getappdata(parent,'CurrentDataSet');

binData = getappdata(parent,'binData');
if isempty(binData) || isempty([binData.groups.binnums])   
    error('No bins have been defined');
end

% roiData = getappdata(parent,'roiData');
% useRois = ~(isempty(roiData) || isempty([roiData.groups.binnums]));   

trialData = getappdata(parent,'trialData');
fixData = getappdata(parent,'fixationData');
regData = getappdata(parent,'regData');
roiData = getappdata(parent,'regData');

for currentDataSet = 1:length(trialData)
    setappdata(parent,'CurrentDataSet',currentDataSet)
    if isempty(trialData) || isempty([trialData(currentDataSet).trials.number])   
        error('No trials have been defined for this data set');
    end
    % if  isempty([trialData(currentDataSet).trials.fixations])   
    %     error('No fixations are found');
    % end
    if isempty([trialData(currentDataSet).trials.binGroup])   
        error('Trials have not been associated with any sampling bins');
    end

    % X,Y positions of bin centers  for each fixation

    % posField = 'meanPos';

    % fixtrialind = zeros(nfix,1);
    % bincenters = zeros(nfix*nbin,2);

    % allfixpos = cat(1,fixData.fix.(posField));

    % fixpos = [];
    binpos = [];
    cr = 0;

    binGroupCodes = [binData.groups.code];
    nbinsfx = [];
    fixbinsovlp =[];
    trialIndex = [];
    fixationIndex = [];
    binI = [];
    
    for i = 1:length(trialData(currentDataSet).trials)    

        binIndex = ismember(binGroupCodes,trialData(currentDataSet).trials(i).binGroup);
        nbin = trialData(currentDataSet).trials(i).nbin;
        nfix = trialData(currentDataSet).trials(i).nfix;
        if ~isempty(fixData) && nfix ~=0 
            nbinsfx(end+(1:nfix)) = nbin;
            fixinds = kron( trialData(currentDataSet).trials(i).fixations', ones(trialData(currentDataSet).trials(i).nbin,1) );
            assigninds = cr + ( 1 : nfix*nbin);
        %     fixpos(assigninds ,:) = allfixpos(fixinds,:); % position of each fixation       
            bincent = cat(1,binData.groups(binIndex).centers);     
            fm = trialData(currentDataSet).trials(i).fixmat';
            fixbinsovlp = cat(1,fixbinsovlp,fm(:));
            binpos( assigninds,: ) = repmat( bincent, nfix,1); %position of each bin center
            trialIndex( assigninds,: ) = i; %position of each bin center
            if ~isempty(assigninds)
                fixationIndex( assigninds,: ) = fixinds; %position of each bin center
            end
            cr = cr + nbin*nfix;
        end
    end


%     currentDataSet= getappdata(parent,'CurrentDataSet');
    % currentModel= getappdata(parent,'CurrentModel');

    if length(regData) < currentDataSet || isempty([regData(currentDataSet).regressors.code])
        regData(currentDataSet).trialIndex = trialIndex;
        regData(currentDataSet).fixationIndex = fixationIndex;
        regData(currentDataSet).codeincr = 0;
        regData(currentDataSet).regressors(1) = makeregressor(full(fixbinsovlp ),'label','BinMembership','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
        regData(currentDataSet).regressors(2) = makeregressor(binpos,'label','BinXY','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr+1);

    %     regData(currentDataSet).regressors(2) = makeregressor(getDistToBinRadial(hObject, eventdata, handles,0),'FixPolarD[0]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
    %     regData(currentDataSet).regressors(2) = makeregressor(getDistToBinRadial(hObject, eventdata, handles,-1),'label','FixPolarD[-1]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
    %     regData(currentDataSet).regressors(3) = makeregressor(getDistToBinRadial(hObject, eventdata, handles,-2),'label','FixPolarD[-2]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
    %     
    %     
    %     regData(currentDataSet).regressors(2) = makeRegressor(fixpos,...
    %                         'FixXY[0]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
        setappdata(parent,'regData',regData)
        regData(currentDataSet).regressors(3) = makeregressor(getShiftedXYFromFixation(hObject, eventdata, handles,-1),...
                            'label','FixXY[-1]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr+2);
        regData(currentDataSet).regressors(4) = makeregressor(getShiftedXYFromFixation(hObject, eventdata, handles,-2),...
                            'label','FixXY[-2]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr+3);
        regData(currentDataSet).regressors(5) = makeregressor(getShiftedXYFromFixation(hObject, eventdata, handles,-3),...
                            'label','FixXY[-3]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr+4);

    %     regData(currentDataSet).regressors(1) = makeRegressor(fixpos,'FixXY[0]','noptions',nbinsfx,'codeincr',regData(currentDataSet).codeincr);
        regData(currentDataSet).codeincr = max([regData(currentDataSet).regressors.code]);
%         setappdata(parent,'regData',regData)
    setappdata(parent,'regData',regData)

    end

end

setappdata(parent,'CurrentDataSet',crdat)

setappdata(parent,'regData',regData)


%----------------------------------------------------------------
function RAng = getDistToBinRadial(hObject, eventdata, handles,varargin)

% Returns the distance of each bin and angle to the (k+shift)'th fixation, where k is
% the k'th fixation event in the model. Angle is clockwise with 0
% corresponding to straight up (12 O'Clock). Units of bin position are
% assumed to have [0 0] as upper left corner

if nargin < 4
    shift = 0;
else
    shift = varargin{1};
end

% Returns a regressor for fixation position, shifted in sequence time by shift from the current fixation.



%Set up the default regressors

parent = getappdata(handles.figure1,'parent');

% binData = getappdata(parent,'binData');
regData = getappdata(parent,'regData');

currentDataSet = getappdata(parent,'CurrentDataSet');


% roiData = getappdata(parent,'roiData');
    
trialData = getappdata(parent,'trialData');
if isempty(trialData) || isempty([trialData(currentDataSet).trials.number])   
    error('No trials have been defined');
end
if  isempty([trialData(currentDataSet).trials.fixations])   
    error('No trials have been defined');
end
if isempty([trialData(currentDataSet).trials.binGroup])   
    error('Trials have not been associated with any sampling bins');
end



% X,Y positions of bin centers  for each fixation

posField = 'meanPos';

% fixtrialind = zeros(nfix,1);
% bincenters = zeros(nfix*nbin,2);
fixData = getappdata(parent,'fixationData');

allfixpos= cat(1,fixData(currentDataSet).fix.(posField));

nfixs = size(allfixpos,1);

allfixposshift = nan(size(allfixpos));

allfixposshift( max([1 , -shift+1]) : min([nfixs,nfixs-shift]),: ) =...
            allfixpos ( max([1 ,(shift+1)]) : min([nfixs,nfixs+shift]),: );
    



fixpos = [];

cr = 0;
for i = 1:length(trialData(currentDataSet).trials)    
    
    nbin = trialData(currentDataSet).trials(i).nbin;
    nfix = trialData(currentDataSet).trials(i).nfix;
    fixinds = kron( trialData(currentDataSet).trials(i).fixations', ones(trialData(currentDataSet).trials(i).nbin,1) );
    assigninds = cr + ( 1 : nfix*nbin);
    fixpos(assigninds ,:) = allfixposshift(fixinds,:); % position of each fixation       
   
    cr = cr + nbin*nfix;
end


% We will correct for screen aspect ratio
scrndata = getappdata(parent,'screenData');

fxnormMat = diag([1 1]./scrndata.res(1)); %Fixation position is normalized to width

binnormMat = diag(scrndata.res./scrndata.res(1));

Dvec = (unsparsify( regData(currentDataSet).regressors(1).value,'transpose')*binnormMat - fixpos*fxnormMat) ;

RAng(:,1) = sqrt(sum( (Dvec).^2 ,2)); %Normalized radial distance 

RAng(:,2) = atan2(Dvec(:,1),-Dvec(:,2)); %Normalized angle



%----------------------------------------------------------------
function DFix =getShiftedXYFromFixation(hObject, eventdata, handles,varargin)

% Returns the distance of each bin and angle to the (k+shift)'th fixation, where k is
% the k'th fixation event in the model. Angle is clockwise with 0
% corresponding to straight up (12 O'Clock). Units of bin position are
% assumed to have [0 0] as upper left corner

if nargin < 4
    shift = 0;
else
    shift = varargin{1};
end

% Returns a regressor for fixation position, shifted in sequence time by shift from the current fixation.



%Set up the default regressors

parent = getappdata(handles.figure1,'parent');

% binData = getappdata(parent,'binData');
regData = getappdata(parent,'regData');

currentDataSet = getappdata(parent,'CurrentDataSet');


% roiData = getappdata(parent,'roiData');
    
trialData = getappdata(parent,'trialData');
if isempty(trialData) || isempty([trialData(currentDataSet).trials.number])   
    error('No trials have been defined');
end
if  isempty([trialData(currentDataSet).trials.fixations])   
    error('No trials have been defined');
end
if isempty([trialData(currentDataSet).trials.binGroup])   
    error('Trials have not been associated with any sampling bins');
end



% X,Y positions of bin centers  for each fixation

posField = 'meanPos';

% fixtrialind = zeros(nfix,1);
% bincenters = zeros(nfix*nbin,2);
fixData = getappdata(parent,'fixationData');

allfixpos= cat(1,fixData(currentDataSet).fix.(posField));

nfixs = size(allfixpos,1);

allfixposshift = nan(size(allfixpos));

allfixposshift( max([1 , -shift+1]) : min([nfixs,nfixs-shift]),: ) =...
            allfixpos ( max([1 ,(shift+1)]) : min([nfixs,nfixs+shift]),: );
    



fixpos = [];

cr = 0;
for i = 1:length(trialData(currentDataSet).trials)    
    
    nbin = trialData(currentDataSet).trials(i).nbin;
    nfix = trialData(currentDataSet).trials(i).nfix;
    fixinds = kron( trialData(currentDataSet).trials(i).fixations', ones(trialData(currentDataSet).trials(i).nbin,1) );
    assigninds = cr + ( 1 : nfix*nbin);
    fixpos(assigninds ,:) = allfixposshift(fixinds,:); % position of each fixation       
   
    cr = cr + nbin*nfix;
end


% We will correct for screen aspect ratio
scrndata = getappdata(parent,'screenData');
fxnormMat = diag(scrndata.res.^-1); %Fixation position is normalized to width
% 
% fxnormMat = diag([1 1]./scrndata.res(1)); %Fixation position is normalized to width
% 
% binnormMat = diag(scrndata.res./scrndata.res(1));

if isequal(regData(currentDataSet).regressors(2).info.form,'sparse')
    DFix = unsparsify( regData(currentDataSet).regressors(2).value,'transpose') - fixpos*fxnormMat ;
else
    DFix = regData(currentDataSet).regressors(2).value- fixpos*fxnormMat ;
end
% DFix(:,1) = sqrt(sum( (Dvec).^2 ,2)); %Normalized radial distance
% 
% DFix(:,2) = atan2(Dvec(:,1),-Dvec(:,2)); %Normalized angle
% 



% --- Executes on button press in displayCheck.
function displayCheck_Callback(hObject, eventdata, handles)
% hObject    handle to displayCheck (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

parent = getappdata(handles.figure1,'parent');
bmh = getappdata(parent,'BinManager');
if ~isempty(bmh) && ishandle(bmh) && get(handles.displayCheck,'value')
    bmhandles = guidata(bmh);
    set(bmhandles.displayCheck,'value',0)
end
% Hint: get(hObject,'Value') returns toggle state of displayCheck
 UpdateFields(hObject, eventdata, handles)



% --------------------------------------------------------------------
function modify_menu_Callback(hObject, eventdata, handles)
% hObject    handle to modify_menu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


