function varargout = GazeReader(varargin)
% GAZEREADER M-file for GazeReader.fig
%      GAZEREADER, by itself, creates a new GAZEREADER or raises the existing
%      singleton*.
%
%      H = GAZEREADER returns the handle to a new GAZEREADER or the handle to
%      the existing singleton*.
%
%      GAZEREADER('CALLBACK',hObject,eventData,handles,...) calls the local
%      function named CALLBACK in GAZEREADER.M with the given input arguments.
%
%      GAZEREADER('Property','Value',...) creates a new GAZEREADER or raises the
%      existing singleton*.  Starting from the left, property value pairs are
%      applied to the GUI before GazeReader_OpeningFunction gets called.  An
%      unrecognized property name or invalid value makes property application
%      stop.  All inputs are passed to GazeReader_OpeningFcn via varargin.
%
%      *See GUI Options on GUIDE's Tools menu.  Choose "GUI allows only one
%      instance to run (singleton)".
%
% See also: GUIDE, GUIDATA, GUIHANDLES

% Edit the above text to modify the response to help GazeReader

% Last Modified by GUIDE v2.5 22-Dec-2007 20:48:51

% Begin initialization code - DO NOT EDIT
gui_Singleton = 1;
gui_State = struct('gui_Name',       mfilename, ...
                   'gui_Singleton',  gui_Singleton, ...
                   'gui_OpeningFcn', @GazeReader_OpeningFcn, ...
                   'gui_OutputFcn',  @GazeReader_OutputFcn, ...
                   'gui_LayoutFcn',  [] , ...
                   'gui_Callback',   []);
if nargin && ischar(varargin{1})
    gui_State.gui_Callback = str2func(varargin{1});
end

if nargout
    [varargout{1:nargout}] = gui_mainfcn(gui_State, varargin{:});
else
    gui_mainfcn(gui_State, varargin{:});
end
% End initialization code - DO NOT EDIT


% --- Executes just before GazeReader is made visible.
function GazeReader_OpeningFcn(hObject, eventData, handles, varargin)
% This function has no output args, see OutputFcn.
% hObject    handle to figure
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)
% varargin   command line arguments to GazeReader (see VARARGIN)


% Default screen properties
screenData.res =[1024 768];
screenData.size = 0;
screenData.distance = 0;

%initialize data structures

hfig = handles.figure1;

% setappdata(hfig ,'buttonState',0);
setappdata(hfig ,'buttonNumber',0);
setappdata(hfig ,'roiData',[]);
setappdata(hfig ,'trialData',struct('images',makeImageStruct,'trial',makeTrialStruct));
setappdata(hfig ,'CurrentTrial',0);
setappdata(hfig ,'CurrentImage',0);
setappdata(hfig ,'CurrentBinGroup',0);
setappdata(hfig ,'children',[]);
setappdata(hfig,'activeControl','main');
setappdata(hfig,'screenData',screenData);


set(handles.figure1,'DeleteFcn',@Destructor)



% set(handles.figure1,'WindowButtonDownFcn',  @FigureButtonDownFcn )
% set(handles.figure1,'WindowButtonUpFcn',  @FigureButtonUpFcn )
set(handles.figure1,'units',  'pixels')

set(handles.axes2,'units',get(handles.axes1,'units'),'position',get(handles.axes1,'position'),...
            'Ydir',get(handles.axes1,'Ydir'));

axlim([2 4]) = screenData.res;
axis(handles.axes1,axlim)
axis(handles.axes1,'manual')
% axis(handles.axes2,axlim)
axis(handles.axes2,[0 1 0 1]) %axes2 is in screen normalized coordinates
axis(handles.axes1,'manual')
% axis(handles.axes2,'manual')
% Choose default command line output for GazeReader
handles.output = hObject;

% Update handles structure
guidata(hObject, handles);

% UIWAIT makes GazeReader wait for user response (see UIRESUME)
% uiwait(handles.figure1);


% --- Outputs from this function are returned to the command line.
function varargout = GazeReader_OutputFcn(hObject, eventData, handles) 
% varargout  cell array for returning output args (see VARARGOUT);
% hObject    handle to figure
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% Get default command line output from handles structure
varargout{1} = handles.output;


% --------------------------------------------------------------------
function loadData_menu_Callback(hObject, eventData, handles)
% hObject    handle to loadData_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[fname,pth] = uigetfile('*.mat');
savefname = strcat(pth,fname);

matvars= whos('-file',savefname);

varnames = {matvars.name};

if ~ismember('gazeReaderData',varnames)   
    errordlg(sprintf('%s doesn''t\ncontain GazeReader Data',fname));
    return
end

load(savefname)

fields = fieldnames(gazeReaderData);
dataFields = fields(~cellfun('isempty',regexp(fields,'.*Data$')));

for i = 1:length(dataFields)
    setappdata(handles.figure1,dataFields{i},gazeReaderData.(dataFields{i}));
end
setappdata(handles.figure1,'savefname',savefname)

% --------------------------------------------------------------------
function loadImage_menu_Callback(hObject, eventData, handles) %#ok<DEFNU>
% hObject    handle to loadImage_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function File_Callback(hObject, eventData, handles)
% hObject    handle to File (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function samplingBins_menu_Callback(hObject, eventData, handles)
% hObject    handle to samplingBins_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function tools_menu_Callback(hObject, eventData, handles)
% hObject    handle to tools_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_3_Callback(hObject, eventData, handles)
% hObject    handle to Untitled_3 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function grid_menu_Callback(hObject, eventData, handles)
% hObject    handle to grid_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



if ~isappdata(handles.figure1,'gridManager') || isempty(getappdata(handles.figure1,'gridManager')) || ~ishandle(getappdata(handles.figure1,'gridManager')) 
    h = GridManager(handles.figure1);
%     [h,gridManagerFunctions] = GridManager(handles.figure1);
%     setappdata(handles.figure1,'gridManager',h);
%     setappdata(handles.figure1,'gridManagerFunctions',gridManagerFunctions);
    children = getappdata(handles.figure1,'children');
    children(end+1) = h;
    setappdata(handles.figure1,'children',children)
else
    h = getappdata(handles.figure1,'gridManager');
    figure(h)
     setappdata(handles.figure1,'activeControl','gridManager');

end

 figurePositionManager(h, handles,0)

% --------------------------------------------------------------------
function samplingBins_Rectangles_menu_Callback(hObject, eventData, handles)
% hObject    handle to samplingBins_Rectangles_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function polygon_Menu_Callback(hObject, eventData, handles)
% hObject    handle to polygon_Menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Ellipses_Callback(hObject, eventData, handles)
% hObject    handle to Ellipses (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function modelFitting_menu_Callback(hObject, eventData, handles)
% hObject    handle to modelFitting_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_9_Callback(hObject, eventData, handles)
% hObject    handle to Untitled_9 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function createRegressors_menu_Callback(hObject, eventData, handles)
% hObject    handle to createRegressors_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)




% --------------------------------------------------------------------
function new_Menu_Callback(hObject, eventData, handles)
% hObject    handle to new_Menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function save_menu_Callback(hObject, eventData, handles)
% hObject    handle to save_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

savefname = getappdata(handles.figure1,'savefname');


if isempty(savefname)
    saveAs_menu_Callback(hObject, eventData, handles)
else
    gazeReaderData = getappdata(handles.figure1);     %#ok<NASGU>
    save(savefname,'gazeReaderData');
end

% --------------------------------------------------------------------
function saveAs_menu_Callback(hObject, eventData, handles)
% hObject    handle to saveAs_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

[fname,pth] = uiputfile('*.mat');

if isnumeric(fname)
   return
end


savefname = strcat(pth,fname);    
setappdata(handles.figure1,'savefname',savefname);
save_menu_Callback(hObject, eventData, handles)
    



% --------------------------------------------------------------------
function trial_Menu_Callback(hObject, eventData, handles)
% hObject    handle to trial_Menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function triaBuilder_menu_Callback(hObject, eventData, handles)
% hObject    handle to triaBuilder_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function import_menu_Callback(hObject, eventData, handles)
% hObject    handle to import_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function importEytrackerData_menu_Callback(hObject, eventData, handles)
% hObject    handle to importEytrackerData_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


supported_file_types = {'edf','fix','eyd'};

dataFileDir = getappdata(handles.figure1,'dataFileDir');

[filenames,fpath] = uigetfile({sprintf('%s;',supported_file_types{:})},'Select a Data File', dataFileDir ,'multiselect','on');

if isnumeric(filenames)
    return
end

setappdata(handles.figure1,'dataFileDir',fpath)

eyetrackerData = getappdata(handles.figure1,'eyetrackerData');
currentDataSet = 1 + length(eyetrackerData);
setappdata(handles.figure1,'CurrentDataSet',currentDataSet);

if ~iscell(filenames)
    filenames = {filenames};
end

for i = 1:length(filenames)
    filename = filenames{i};

    [a,b,ext] = fileparts(filename);

    switch lower(ext)

        case '.edf'
            [fixdata,rawdata] = readEDF(fullfile(fpath,filename));        
        case '.fix'
            fixdata = readFIX(fullfile(fpath,filename));        
            try
                rawdata = readEYD(fullfile(fpath,regexprep(filename,'\.fix$','\.eyd'))); 
            catch
                rawdata = [];
                warning(sprintf('Unable to find a .eyd file with the same name as this .fix file.\nOnly fixation data is loaded.'))
            end
        case '.eyd'
            rawdata = readEYD(fullfile(fpath,filename));        
            try
                fixdata = readFIX(fullfile(fpath,regexprep(filename,'\.eyd$','\.fix'))); 
            catch
                fixdata = [];
                warning(sprintf('Unable to find a .fix file for this raw .eyd file.\nOnly raw data is loaded.'))
            end
        otherwise
                error('Unsupported file type.');
    end

    if isempty(eyetrackerData)
     eyetrackerData = struct('raw',[],'fix',[]);
    end
    eyetrackerData(currentDataSet + i-1) = struct('raw',[],'fix',[]);
    
    eyetrackerData(currentDataSet + i-1).raw = rawdata;
    eyetrackerData(currentDataSet + i-1).fix = fixdata;
    eyetrackerHeader(currentDataSet + i-1).filename = filename;
    eyetrackerHeader(currentDataSet + i-1).label= sprintf('Data %i',currentDataSet + i-1);
    eyetrackerHeader(currentDataSet + i-1).filetype = ext(2:end);
    eyetrackerHeader(currentDataSet + i-1).info= [];

end

setappdata(handles.figure1,'eyetrackerData',eyetrackerData);
setappdata(handles.figure1,'eyetrackerHeaderData',eyetrackerHeader);

viewDataSetsMenu_Callback(hObject,eventdata,handles);



% --------------------------------------------------------------------
function importMatFile_menu_Callback(hObject, eventData, handles)
% hObject    handle to importMatFile_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Text_menu_Callback(hObject, eventData, handles)
% hObject    handle to Text_menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)



% %------------------------------------------------
%   
% function FigureButtonDownFcn(hObject,eventData)


%------------------------------------------------
  
function gridManagerIsAcctive_ButtonDnFcn(hObject,eventData,handles)

% Callback for the main figure window when the Grid Manager is Active


handles = guidata(hObject);

axhandles = cat(1,handles.axes1,get(handles.axes1,'children'),...
                  handles.axes2,get(handles.axes2,'children'));              
                   
if ~ismember(gco,axhandles)
    return
end


if ~isequal(get(handles.figure1,'selectiontype'),'normal') %Only left button single click will activate resizing
    return
end
currentBinGroup= getappdata(handles.figure1,'CurrentBinGroup');
binData = getappdata(handles.figure1,'binData');
% trialData = getappdata(handles.figure1,'trialData');
% screenData = getappdata(handles.figure1,'screenData');
if currentBinGroup==0 || ~strcmp(binData.groups(currentBinGroup).type,'grid')
    figure(handles.figure1)
    return
end

axlim = axis(handles.axes2);

if ishandle(getappdata(handles.figure1,'gridManager'))
    gmhandles = guidata(getappdata(handles.figure1,'gridManager'));
else
    gmhandles = guidata(gridManager(handles.figure1));
    setappdata(handles.figure1,'GridManager',gmhandles)
    binData = getappdata(handles.figure1,'binData');

end

if isempty(binData.groups(currentBinGroup).pos )
    newbin = makeBinData({[0 1 0 1],[15 15]},'type','grid','label','New Grid');
    binData.groups(currentBinGroup) = newbin.groups;
end            

if currentBinGroup ~= 0    
     
    newpos = repositionBox(binData.groups(currentBinGroup).inputData, handles.axes2);    
    nbins = str2num([get(gmhandles.Nx,'string'),'  ',get(gmhandles.Ny,'string')]); %#ok<ST2NM>
    binData.groups(currentBinGroup).inputData = {newpos./axlim([2 2 4 4])};
    binData.groups(currentBinGroup).inputData{2} = nbins;
    binData.groups(currentBinGroup).pos = grid2rect(binData.groups(currentBinGroup).inputData);
end


setappdata(handles.figure1,'binData',binData);
gridfuns = getappdata(handles.figure1,'gridManagerFunctions');

gridfuns.updateFields(hObject,eventData,guidata(getappdata(handles.figure1,'gridManager')));

if ishandle(getappdata(handles.figure1,'BinManager'))
    setappdata(handles.figure1,'CurrentBin',0)
    binfuns = getappdata(handles.figure1,'binManagerFunctions');
    binfuns.update(hObject,eventData,guidata(getappdata(handles.figure1,'BinManager')))
else
%     gridfuns.updateBinData(hObject,eventData,guidata(getappdata(handles.figure1,'gridManager')));
    gridfuns.updatePlot(hObject,eventData,guidata(getappdata(handles.figure1,'gridManager')));
end
figure(handles.figure1);

%------------------------------------------------

function binManagerIsAcctive_ButtonDnFcn(hObject,eventData, handles)

% Callback for the main figure window when the BinManager is Active

MoveBins(hObject, eventData,handles);

figure(handles.figure1);

%------------------------------------------------
  
% function FigureButtonUpFcn(hObject,eventData)
% 
% setappdata(hObject,'buttonState',0)
% setappdata(hObject,'buttonNumber',0)


% --------------------------------------------------------------------
function Images_Menu_Callback(hObject, eventData, handles)
% hObject    handle to Images_Menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


if ~isappdata(handles.figure1,'ImageManager') || isempty(getappdata(handles.figure1,'ImageManager')) || ~ishandle(getappdata(handles.figure1,'ImageManager')) 
    [h,imageManagerFunctions] = imageManager(handles.figure1);
    setappdata(handles.figure1,'imageManager',h);
    setappdata(handles.figure1,'imageManagerFunctions',imageManagerFunctions);
    children = getappdata(handles.figure1,'children');
    children(end+1) = h;
    setappdata(handles.figure1,'children',children)
else
    h = getappdata(handles.figure1,'imageManager');
    figure(h)
    setappdata(handles.figure1,'activeControl','imageManager');

end

 figurePositionManager(h, handles,0)

% --------------------------------------------------------------------
function   ImageManagerIsAcctive_ButtonDnFcn(hObject,eventData,handles)

% 
%

                   
axhandles = cat(1,handles.axes1,get(handles.axes1,'children'),...
                  handles.axes2,get(handles.axes2,'children'));              
                   
if ~ismember(gco,axhandles)
    return
end

imhandles = guidata(getappdata(handles.figure1,'imageManager'));


if get(imhandles.scaleCheckBox,'value') %No repositioning if the image is scaled to screen
    return
end

imfuns =  getappdata(handles.figure1,'imageManagerFunctions');

if ~isequal(get(handles.figure1,'selectiontype'),'normal')
    return
end
currentImage = getappdata(handles.figure1,'CurrentImage');
trialData = getappdata(handles.figure1,'trialData');

if currentImage ~= 0    
    imhandles = guidata(getappdata(handles.figure1,'imageManager'));
    newpos = repositionBox(trialData.images(currentImage).position, handles.axes2);    
    dpd = abs(diff(trialData.images(currentImage).position  - newpos));
    if ~get(imhandles.pixelScaleCheckBox,'value') || (dpd(1) < 1e-10 && dpd(3) < 1e-10 )
        trialData.images(currentImage).position = newpos;
    end
%     trialData.images(currentImage).position = newpos./trialData.images(currentImage).screenres([1 1 2 2]);
    
end
 
setappdata(handles.figure1,'trialData',trialData);
imfuns.UpdateImage(hObject,eventData,guidata(getappdata(handles.figure1,'imageManager')));
    
% --------------------------------------------------------------------
function newaxrect = repositionBox(axrectnormin, ax)

if iscell(axrectnormin)
    axrectnormin = axrectnormin{1};
end

selectionTol = 10;

% A function for repositioning rectangular areas using rbbox and dragrect-
% converting from figure corrdinates to axis coordinates

currpt = get(ax, 'CurrentPoint');
currpt = currpt(1,1:2);

set(ax,'units', get(get(ax,'parent'),'units') )

axpos = get(ax,'position'); %Position of axis in figure

% screenData = getappdata(handles.figure1,'screenData');

minmax = cat(1,min(axrectnormin,[],1),max(axrectnormin,[],1)); %use only extreme corners for groups of rectangles
axrectnorm = minmax([1 4 5 8]);

% axlim = screenData.res;
axlim = axis(ax);

axrect= axrectnorm.*axlim([2 2 4 4]);
% axrect = axrect([1 2 4 3]); %reverse x and y to be consistent with xfig

xyfig = [axpos(1) axpos(2); axpos(1)+axpos(3), axpos(2);...
          axpos(1:2)+axpos(3:4); axpos(1), axpos(2)+axpos(4)];   

xyax = [axlim([1 4]) ;axlim([2 4]);  axlim([2 3]); axlim([1 3])];

xyax(:,end+1)= 1;
 xyfig(:,end+1) = 1;

% ax2fig = (xyax'*xyax)^-1*(xyax'*xyfig(:,1:2));
% fig2ax = (xyfig'*xyfig)^-1*(xyfig'*xyax(:,1:2));
ax2fig = (xyax'*xyax)^-1*(xyax'*xyfig);
% fig2ax = (xyfig'*xyfig)^-1*(xyfig'*xyax);

figrectmat =   [axrect([1 4])  1;axrect([2 3]) 1]*ax2fig;

figrect = figrectmat([1 2 3 4]);

figpt =  [currpt 1]*ax2fig ;

corners = [figrect([1 3]); figrect([2 3]); figrect([2 4]); figrect([1 4])];

d = sqrt(sum( (corners - repmat(figpt(:,1:2),4,1)).^2,2));

[mind,minc] = min(d);

cornerSelect = 0;
if mind < selectionTol
    cornerSelect = minc;
end

figrectInCornerWidthFormat = figrect([1 3 2 4]) - [0,0,figrect([1 3])];

if cornerSelect ==0
    
    newfigrect = dragrect(figrectInCornerWidthFormat);
    
else
    newfigrect = rbbox(figrectInCornerWidthFormat,corners(mod(cornerSelect+1,4)+1,:));
end

newfigmat = [newfigrect([1 2]);newfigrect([1 2])+[newfigrect(3) 0 ] ;...
             newfigrect([1 2])+newfigrect(3:4); newfigrect([1 2]) + [0 newfigrect(4) ]];
newfigmat(:,end+1) = 1;
newaxmat = newfigmat*ax2fig^-1;
newaxrect = newaxmat([1 2 8 5]);            

% newaxrect = newaxrect([1 2 4 3]); %Back into original format


% --------------------------------------------------------------------
function MoveBins(hObject, eventData,handles)

%Updates plots of the selected bin while the button is down
% and adjusts position based on figure current point
selectionTol = 10;

binData = getappdata(handles.figure1,'binData');
% screenData = getappdata(handles.figure1,'screenData');
currentBinGroup = getappdata(handles.figure1,'CurrentBinGroup');
% currentBin = getappdata(handles.figure1,'CurrentBin');


if currentBinGroup == 0
    return
elseif strcmp(binData.groups(currentBinGroup).type,'grid')
    gridManagerIsAcctive_ButtonDnFcn(hObject,eventData,handles)
end

set(handles.axes1,'units', get(handles.figure1,'units'))
set(handles.axes2,'ydir',get(handles.axes1,'ydir'),'units', get(handles.figure1,'units'))

axpos = get(handles.axes2,'position'); %in figure coordinates
% axlim = axis(handles.axes2)./screenData.res([1 1 2 2]);
axlim = [0 1 0 1]; %axes2 fixed in normalized coordinates

xyfig = [axpos(1) axpos(2); axpos(1)+axpos(3), axpos(2);...
          axpos(1:2)+axpos(3:4); axpos(1), axpos(2)+axpos(4)];   
xyax = [axlim([1 4]) ;axlim([2 4]);  axlim([2 3]); axlim([1 3])];
xyax(:,end+1)= 1;
xyfig(:,end+1) = 1;
ax2fig = (xyax'*xyax)^-1*(xyax'*xyfig);

currpt = get(handles.axes2, 'CurrentPoint');
% currpt = currpt(1,1:2)./screenData.res;
currpt = currpt(1,1:2);
% figpt =  [currpt 1]*ax2fig ;

% d = sqrt(sum( (corners - repmat(figpt(:,1:2),4,1)).^2,2));
% [mind,minc] = min(d);

type = binData.groups(currentBinGroup).type;

if ~isempty(binData.groups(currentBinGroup).pos)
    
    insidebins =  binData.groups(currentBinGroup).ismember( binData.groups(currentBinGroup), currpt,selectionTol/sqrt(abs(det(ax2fig))));

else isempty(binData.groups(currentBinGroup).pos) 
    
    switch type
        case 'grid'
            return
        case 'rect'
            newbindata = makeBinData(currpt([1 1 2 2]),'type',type,'label',binData.groups(currentBinGroup).label);
        case 'ellipse'
            newbindata = makeBinData([currpt 0],'type',type,'label',binData.groups(currentBinGroup).label);
        case 'poly'
            newbindata = makeBinData(currpt,'type',type,'label',binData.groups(currentBinGroup).label);            
    end
    
    binData.groups(currentBinGroup) = newbindata.groups;
    insidebins = 1;
% else
%     
%     insidebins =  binData.groups(currentBinGroup).ismember( binData.groups(currentBinGroup), currpt);
%     if ~any(insidebins)
%         return
%     end
end

if ~any(insidebins)
    pos = binData.groups(currentBinGroup).pos;
    switch type
        case 'grid'
            return
        case 'rect'
            newbindata = makeBinData(cat(1,pos,currpt([1 1 2 2])),'type',type,'label',binData.groups(currentBinGroup).label);
        case 'ellipse'
            newbindata = makeBinData(cat(1,pos,[currpt 0 0 0 ]),'type',type,'label',binData.groups(currentBinGroup).label);
        case 'poly'
            newbindata = makeBinData(cat(1,pos,currpt),'type',type,'label',binData.groups(currentBinGroup).label);            
    end
    
    binData.groups(currentBinGroup) = newbindata.groups;
    insidebins(size(binData.groups(currentBinGroup).pos,1)) = true;

end

% type = binData.groups(currentBinGroup).type;
% 
if ~strcmp(type,'poly') 
    insidecenters = binData.groups(currentBinGroup).centers(insidebins,:);
    insideindex = find(insidebins);
    dists = sqrt(sum(insidecenters - repmat(currpt,size(insidecenters,1),1).^2,2));
    [mind, ind] = min(dists);
    currentBin = insideindex(ind);
    setappdata(handles.figure1,'CurrentBin',currentBin);
    pos = binData.groups(currentBinGroup).pos(currentBin,:);
else
    pos = binData.groups(currentBinGroup).pos;
    currentBin = 0;
%     dists = sqrt(sum((pos- repmat(currpt,size(pos,1),1)).^2,2));
%     [mind, currentVertex ] = min(dists);
end    
%Find the closest bin in the group



startfpt = get(handles.figure1,'CurrentPoint');
% startfpt = getappdata(handles.figure1,'CurrentFigPoint');

axes(handles.axes2)
hold(handles.axes2,'on')
phs = binData.groups(currentBinGroup).plot(binData.groups(currentBinGroup),currentBin,'g--','parent',handles.axes2);
% axes(handles.axes2)
switch type
    
    case 'grid' %already handled above
    case 'rect'
        
        corners = reshape(pos([1 4 2 4 2 3 1 3]),2,4)';
        corners(:,end+1) =1;
        
        fcorners = corners*ax2fig;
        currfpt = fcorners;
        
        [minfd,minfc] = min( sqrt(sum((fcorners(:,1:2) - repmat(startfpt ,4,1)).^2,2)));
        
        modindex = mod(minfc - 1 + ([0 1 3] ),4)+1; 
            
        while getappdata(handles.figure1,'ButtonDown')
            pause(.05)

            newfpt = get(handles.figure1,'CurrentPoint');
%             newfpt = getappdata(handles.figure1,'CurrentFigPoint');
            D = newfpt - startfpt ;
            
            if minfd < selectionTol
                if mod(minfc,2) == 1
                    currfpt( modindex,1:2) = cat(1,D, flipud(diag(D))) + fcorners( modindex,1:2) ;
                else
                    currfpt( modindex,1:2) = cat(1,D, diag(D)) + fcorners(modindex,1:2);
                end            
            else
                currfpt(:,1:2) = fcorners(:,1:2) + repmat(D,4,1);
            end
            corners = currfpt/ax2fig;
            rect = corners([1 2 7 6]);
            rect = [min(rect(1:2)) max(rect(1:2)),...
                    min(rect(3:4)) max(rect(3:4))];
                
            binData.groups(currentBinGroup).pos(currentBin,:) = rect;
            delete(phs)
            phs = binData.groups(currentBinGroup).plot(binData.groups(currentBinGroup),currentBin,'g--','parent',handles.axes2);
            axis(handles.axes2,'off')
            
            drawnow    
        end
%         0
    case 'ellipse'
        
        %transformation from normalized ellipse coordinates to axis
        %coordinates
        trmat = diag([pos(3:4),1])*[cos(pos(5)), -sin(pos(5)),   0  
                                     sin(pos(5))  cos(pos(5))   0 
                                    pos(1)        pos(2)    1];        
%         itrmat = diag(pos(3:4).^-1)*[cos(pos(5)), sin(pos(5)); -sin(pos(5))  cos(pos(5))];
%          dcent = sqrt(sum( (( [currpt-pos(1:2),0] )/trmat).^2,2)); 
        if ~det(trmat) == 0 
             ptnrm =  [currpt,1]/trmat; %point in ellipse normalized units
            
             drimnrm = [ptnrm(1:2) - ptnrm(1:2)./sqrt(sum(ptnrm.^2)-1),0]; %radial distance vector to the edge of the bin in normalized units
             drimax = drimnrm*trmat; %radial distance to the edge of the bin in axis  units
              dcent = sqrt(sum(drimax.^2));
%              trmat
%              sqrt(sum(ptnrm(1:2).^2))
%              return
        else
             dcent = 0;
             trmat = eye(3);
             trmat(3,1:2) = pos(1:2);
%              ptnrm = [0 0 1];
 
        end
        currpos = pos;
        while getappdata(handles.figure1,'ButtonDown')
            
            newfpt = get(handles.figure1,'CurrentPoint');
%             newfpt = getappdata(handles.figure1,'CurrentFigPoint');
            Df = newfpt - startfpt ;
%             posf = [pos(1:2),1]*ax2fig;
            newpt  = [newfpt,1]/ax2fig;
            newptnrm  = newpt/trmat; % new point in ellipse normalized coordinates
            if ~any(newptnrm(1:2))
                newptnrm   = [1 0 1]/(trmat*ax2fig);
            end
          
%             if abs(dcent - pos(3)) < selectionTol/sqrt(abs(det(ax2fig)))
            if dcent < selectionTol/sqrt(abs(det(ax2fig)))
                if strcmp(get(handles.figure1,'selectiontype'),'normal')
                    sax = cat(2,diag(newptnrm(1:2)),[0 0]')*trmat;%new semi axes in axis coordinates                    
%                     slengths = sqrt(sum(sax.^2,2)-1);
                    slengths = abs(sum(sax,2));
%                     currpos = pos + [0 0 slengths' 0 ]
                    currpos(3:4) = slengths' ;
                elseif strcmp(get(handles.figure1,'selectiontype'),'extend')
                    
                    th = atan2(newptnrm(2),-newptnrm(1));
                    currpos = pos + [0 0 0 0 th ];
                else
                    return
                end
            elseif strcmp(get(handles.figure1,'selectiontype'),'normal')

                currpos(1:3) = pos(1:3) + [Df,0]/ax2fig;
                
            else 
                return
            end
            binData.groups(currentBinGroup).pos(currentBin,:) = currpos;
            delete(phs)
            phs = binData.groups(currentBinGroup).plot(binData.groups(currentBinGroup),currentBin,'g--','parent',handles.axes2);
%             axis(handles.axes2,axlim);
            axis(handles.axes2,'off');
%             gca
%             getappdata(handles.figure1,'CurrentBin')
            drawnow    
%             axis(handles.axes2)

        end                
    case 'poly'

        
        pos(:,end+1) =1;
        fvertices = pos*ax2fig;
        stpos = pos;
        [minfd,minfc] = min(sqrt(sum((fvertices - repmat([startfpt,1] ,size(pos,1),1)).^2)));
        
        while getappdata(handles.figure1,'ButtonDown')

            newfpt = get(handles.figure1,'CurrentPoint');
%             newfpt = getappdata(handles.figure1,'CurrentFigPoint');

            D = newfpt - startfpt ;
            
            if minfd < selectionTol          
                newpt = [newfpt,1]/ax2fig;
                pos(minfc,:) = newpt;
            else
                pos = repmat([D,0]/ax2fig,size(pos,1),1)+stpos;
            end
            
            binData.groups(currentBinGroup).pos = pos(:,1:2);
            delete(phs)
            phs = binData.groups(currentBinGroup).plot(binData.groups(currentBinGroup),currentBin,'g--','parent',handles.axes2);
            axis(handles.axes2,'off')
            drawnow    
        end
end
%         0

setappdata(handles.figure1,'binData',binData)
delete(phs)
bmfuns = getappdata(handles.figure1,'binManagerFunctions');
bmh =  getappdata(handles.figure1,'BinManager');
bmhandles = guidata(bmh);
bmfuns.update(bmh,eventData,bmhandles);


% --------------------------------------------------------------------
function figurePositionManager(figh, handles,vert)

%Decides where to put new windows

if nargin < 3
    vert = 0;
end
rim = 55;

set(figh,'units',get(handles.figure1,'units'));

figpos = get(figh,'position');
mainfigpos = get(handles.figure1,'position');
scrsize = get(0,'screensize');
% pos = [0 1]

newpos = figpos;
if vert
    if scrsize(4) - sum(mainfigpos([2 4])) <= mainfigpos(2)
        newpos(1:2) = mainfigpos(1:2)+[mainfigpos(3)-figpos(3),-figpos(4)-rim] ;
    else
        newpos(1:2) = mainfigpos(1:2)+[mainfigpos(3)-figpos(3),mainfigpos(4)+rim] ;
    end

else
    if scrsize(3) - sum(mainfigpos([1 3])) <= mainfigpos(1)
        newpos(1:2) = mainfigpos(1:2)+[-figpos(3)-rim,mainfigpos(4)-figpos(4)] ;
    else
        newpos(1:2) = mainfigpos(1:2)+[mainfigpos(3)+rim,mainfigpos(4)-figpos(4)] ;
    end
end
set(figh,'position',newpos)
        


% --------------------------------------------------------------------
function Destructor(hObject, eventData)
% hObject    handle to Images_Menu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

children = getappdata(hObject,'children');

for i = 1:length(children)
    if ishandle(children(i)), delete(children(i));end
end


% --- Executes on mouse press over axes background.
function axes1_ButtonDownFcn(hObject, eventData, handles)
% hObject    handle to axes1 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_10_Callback(hObject, eventData, handles)
% hObject    handle to Untitled_10 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_11_Callback(hObject, eventData, handles)
% hObject    handle to Untitled_11 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function Untitled_12_Callback(hObject, eventData, handles)
% hObject    handle to Untitled_12 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


% --------------------------------------------------------------------
function binManagerMenu_Callback(hObject, eventData, handles)
% hObject    handle to binManagerMenu (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

binmgr = BinManager(handles.figure1);
children = getappdata(handles.figure1,'children');
children(end+1) = binmgr;
setappdata(handles.figure1,'children',children)
setappdata(handles.figure1,'BinManager',binmgr)

figurePositionManager(binmgr, handles,0)


% --- Executes on mouse press over figure background, over a disabled or
% --- inactive control, or over an axes background.
function figure1_WindowButtonDownFcn(hObject, eventData, handles)
% hObject    handle to figure1 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)


%What to do when a button is pressed over the window
handles = guidata(hObject);
setappdata(handles.figure1,'ButtonDown',1)
switch getappdata(hObject,'activeControl')
    
    case 'gridManager'
         gridManagerIsAcctive_ButtonDnFcn(hObject,eventData, handles);
    case 'imageManager'
          ImageManagerIsAcctive_ButtonDnFcn(hObject,eventData, handles);
    case 'binManager'
          binManagerIsAcctive_ButtonDnFcn(hObject,eventData, handles);
        
    case 'main'
end


% --- Executes on mouse press over figure background, over a disabled or
% --- inactive control, or over an axes background.
function figure1_WindowButtonUpFcn(hObject, eventData, handles)
% hObject    handle to figure1 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

setappdata(handles.figure1,'ButtonDown',0);


% --- Executes on mouse motion over figure - except title and menu.
function figure1_WindowButtonMotionFcn(hObject, eventData, handles)
% hObject    handle to figure1 (see GCBO)
% eventData  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

% setappdata(handles.figure1,'CurrentFigPoint',get(handles.figure1,'CurrentPoint'));
get(handles.figure1,'CurrentPoint');


% --------------------------------------------------------------------
function viewDataSetsMenu_Callback(hObject, eventdata, handles)
% hObject    handle to viewDataSetsMenu (see GCBO)
% eventdata  reserved - to be defined in a future version of MATLAB
% handles    structure with handles and user data (see GUIDATA)

DataSetWindow(handles.figure1);

